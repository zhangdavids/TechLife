<!DOCTYPE html>
<html lang="zh-Hans">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    one-blockchain-src-anal | 上药三品，神与气精
  </title>
  <meta name="description" content="曾因酒醉鞭名马 生怕情多累美人">
  
  <meta name="keywords" content="
  
  ">
  
  <meta name="author" content="Cheung John">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">

  <link rel="icon" type="image/x-icon" href="undefined">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
</head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="/images/pingan.jpeg"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/archives"
           class="header-toolbar-right"> 315 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/tags"
           class="header-toolbar-right"> 28 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories"
           class="header-toolbar-right"> 24 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">上药三品，神与气精</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    Cheung John

    <span class="post-date float-right" title="{{moment(1522161471000).format('MMM DD, YYYY, h:mm:ss A')}}">
      <i class="fa fa-pencil-square-o"></i>
      {{moment(1522161471000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>one-blockchain-src-anal</h1>
    <p>看看代码的实现：</p>
<pre><code>import hashlib
import json
from time import time
from urllib.parse import urlparse
from uuid import uuid4

import requests
from flask import Flask, jsonify, request


class Blockchain:
    def __init__(self):
        self.current_transactions = []
        self.chain = []
        self.nodes = set()

        # Create the genesis block
        self.new_block(previous_hash=&apos;1&apos;, proof=100)

    def register_node(self, address):
        &quot;&quot;&quot;
        Add a new node to the list of nodes

        :param address: Address of node. Eg. &apos;http://192.168.0.5:5000&apos;
        &quot;&quot;&quot;

        parsed_url = urlparse(address)
        if parsed_url.netloc:
            self.nodes.add(parsed_url.netloc)
        elif parsed_url.path:
            # Accepts an URL without scheme like &apos;192.168.0.5:5000&apos;.
            self.nodes.add(parsed_url.path)
        else:
            raise ValueError(&apos;Invalid URL&apos;)


    def valid_chain(self, chain):
        &quot;&quot;&quot;
        Determine if a given blockchain is valid

        :param chain: A blockchain
        :return: True if valid, False if not
        &quot;&quot;&quot;

        last_block = chain[0]
        current_index = 1

        while current_index &lt; len(chain):
            block = chain[current_index]
            print(f&apos;{last_block}&apos;)
            print(f&apos;{block}&apos;)
            print(&quot;\n-----------\n&quot;)
            # Check that the hash of the block is correct
            if block[&apos;previous_hash&apos;] != self.hash(last_block):
                return False

            # Check that the Proof of Work is correct
            if not self.valid_proof(last_block[&apos;proof&apos;], block[&apos;proof&apos;], last_block[&apos;previous_hash&apos;]):
                return False

            last_block = block
            current_index += 1

        return True

    def resolve_conflicts(self):
        &quot;&quot;&quot;
        This is our consensus algorithm, it resolves conflicts
        by replacing our chain with the longest one in the network.

        :return: True if our chain was replaced, False if not
        &quot;&quot;&quot;

        neighbours = self.nodes
        new_chain = None

        # We&apos;re only looking for chains longer than ours
        max_length = len(self.chain)

        # Grab and verify the chains from all the nodes in our network
        for node in neighbours:
            response = requests.get(f&apos;http://{node}/chain&apos;)

            if response.status_code == 200:
                length = response.json()[&apos;length&apos;]
                chain = response.json()[&apos;chain&apos;]

                # Check if the length is longer and the chain is valid
                if length &gt; max_length and self.valid_chain(chain):
                    max_length = length
                    new_chain = chain

        # Replace our chain if we discovered a new, valid chain longer than ours
        if new_chain:
            self.chain = new_chain
            return True

        return False

    def new_block(self, proof, previous_hash):
        &quot;&quot;&quot;
        Create a new Block in the Blockchain

        :param proof: The proof given by the Proof of Work algorithm
        :param previous_hash: Hash of previous Block
        :return: New Block
        &quot;&quot;&quot;

        block = {
            &apos;index&apos;: len(self.chain) + 1,
            &apos;timestamp&apos;: time(),
            &apos;transactions&apos;: self.current_transactions,
            &apos;proof&apos;: proof,
            &apos;previous_hash&apos;: previous_hash or self.hash(self.chain[-1]),
        }

        # Reset the current list of transactions
        self.current_transactions = []

        self.chain.append(block)
        return block

    def new_transaction(self, sender, recipient, amount):
        &quot;&quot;&quot;
        Creates a new transaction to go into the next mined Block

        :param sender: Address of the Sender
        :param recipient: Address of the Recipient
        :param amount: Amount
        :return: The index of the Block that will hold this transaction
        &quot;&quot;&quot;
        self.current_transactions.append({
            &apos;sender&apos;: sender,
            &apos;recipient&apos;: recipient,
            &apos;amount&apos;: amount,
        })

        return self.last_block[&apos;index&apos;] + 1

    @property
    def last_block(self):
        return self.chain[-1]

    @staticmethod
    def hash(block):
        &quot;&quot;&quot;
        Creates a SHA-256 hash of a Block

        :param block: Block
        &quot;&quot;&quot;

        # We must make sure that the Dictionary is Ordered, or we&apos;ll have inconsistent hashes
        block_string = json.dumps(block, sort_keys=True).encode()
        return hashlib.sha256(block_string).hexdigest()

    def proof_of_work(self, last_block):
        &quot;&quot;&quot;
        Simple Proof of Work Algorithm:

         - Find a number p&apos; such that hash(pp&apos;) contains leading 4 zeroes
         - Where p is the previous proof, and p&apos; is the new proof

        :param last_block: &lt;dict&gt; last Block
        :return: &lt;int&gt;
        &quot;&quot;&quot;

        last_proof = last_block[&apos;proof&apos;]
        last_hash = self.hash(last_block)

        proof = 0
        while self.valid_proof(last_proof, proof, last_hash) is False:
            proof += 1

        return proof

    @staticmethod
    def valid_proof(last_proof, proof, last_hash):
        &quot;&quot;&quot;
        Validates the Proof

        :param last_proof: &lt;int&gt; Previous Proof
        :param proof: &lt;int&gt; Current Proof
        :param last_hash: &lt;str&gt; The hash of the Previous Block
        :return: &lt;bool&gt; True if correct, False if not.

        &quot;&quot;&quot;

        guess = f&apos;{last_proof}{proof}{last_hash}&apos;.encode()
        guess_hash = hashlib.sha256(guess).hexdigest()
        return guess_hash[:4] == &quot;0000&quot;


# Instantiate the Node
app = Flask(__name__)

# Generate a globally unique address for this node
node_identifier = str(uuid4()).replace(&apos;-&apos;, &apos;&apos;)

# Instantiate the Blockchain
blockchain = Blockchain()


@app.route(&apos;/mine&apos;, methods=[&apos;GET&apos;])
def mine():
    # We run the proof of work algorithm to get the next proof...
    last_block = blockchain.last_block
    proof = blockchain.proof_of_work(last_block)

    # We must receive a reward for finding the proof.
    # The sender is &quot;0&quot; to signify that this node has mined a new coin.
    blockchain.new_transaction(
        sender=&quot;0&quot;,
        recipient=node_identifier,
        amount=1,
    )

    # Forge the new Block by adding it to the chain
    previous_hash = blockchain.hash(last_block)
    block = blockchain.new_block(proof, previous_hash)

    response = {
        &apos;message&apos;: &quot;New Block Forged&quot;,
        &apos;index&apos;: block[&apos;index&apos;],
        &apos;transactions&apos;: block[&apos;transactions&apos;],
        &apos;proof&apos;: block[&apos;proof&apos;],
        &apos;previous_hash&apos;: block[&apos;previous_hash&apos;],
    }
    return jsonify(response), 200


@app.route(&apos;/transactions/new&apos;, methods=[&apos;POST&apos;])
def new_transaction():
    values = request.get_json()

    # Check that the required fields are in the POST&apos;ed data
    required = [&apos;sender&apos;, &apos;recipient&apos;, &apos;amount&apos;]
    if not all(k in values for k in required):
        return &apos;Missing values&apos;, 400

    # Create a new Transaction
    index = blockchain.new_transaction(values[&apos;sender&apos;], values[&apos;recipient&apos;], values[&apos;amount&apos;])

    response = {&apos;message&apos;: f&apos;Transaction will be added to Block {index}&apos;}
    return jsonify(response), 201


@app.route(&apos;/chain&apos;, methods=[&apos;GET&apos;])
def full_chain():
    response = {
        &apos;chain&apos;: blockchain.chain,
        &apos;length&apos;: len(blockchain.chain),
    }
    return jsonify(response), 200


@app.route(&apos;/nodes/register&apos;, methods=[&apos;POST&apos;])
def register_nodes():
    values = request.get_json()

    nodes = values.get(&apos;nodes&apos;)
    if nodes is None:
        return &quot;Error: Please supply a valid list of nodes&quot;, 400

    for node in nodes:
        blockchain.register_node(node)

    response = {
        &apos;message&apos;: &apos;New nodes have been added&apos;,
        &apos;total_nodes&apos;: list(blockchain.nodes),
    }
    return jsonify(response), 201


@app.route(&apos;/nodes/resolve&apos;, methods=[&apos;GET&apos;])
def consensus():
    replaced = blockchain.resolve_conflicts()

    if replaced:
        response = {
            &apos;message&apos;: &apos;Our chain was replaced&apos;,
            &apos;new_chain&apos;: blockchain.chain
        }
    else:
        response = {
            &apos;message&apos;: &apos;Our chain is authoritative&apos;,
            &apos;chain&apos;: blockchain.chain
        }

    return jsonify(response), 200


if __name__ == &apos;__main__&apos;:
    from argparse import ArgumentParser

    parser = ArgumentParser()
    parser.add_argument(&apos;-p&apos;, &apos;--port&apos;, default=5000, type=int, help=&apos;port to listen on&apos;)
    args = parser.parse_args()
    port = args.port

    app.run(host=&apos;0.0.0.0&apos;, port=port)
</code></pre><p> 提供了几个url:</p>
<pre><code>mine GET

transactions/new POST

chain GET

nodes/register POST

nodes/resolve GET

/transactions/new to create a new transaction to a block
/mine to tell our server to mine a new block.
/chain to return the full Blockchain.
/nodes/register to accept a list of new nodes in the form of URLs.
/nodes/resolve to implement our Consensus Algorithm, which resolves any 
        conflicts—to ensure a node has the correct chain.
</code></pre><p>单个区块：</p>
<pre><code>block = {
    &apos;index&apos;: 1,
    &apos;timestamp&apos;: 1506057125.900785,
    &apos;transactions&apos;: [
        {
            &apos;sender&apos;: &quot;8527147fe1f5426f9dd545de4b27ee00&quot;,
            &apos;recipient&apos;: &quot;a77f5cdfa2934df3954a5c7c7da5df1f&quot;,
            &apos;amount&apos;: 5,
        }
    ],
    &apos;proof&apos;: 324984774000,
    &apos;previous_hash&apos;: &quot;2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824&quot;
}    
</code></pre>
  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="http://yoursite.com" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2018 Cheung John</li>
      <li><a href="http://yoursite.com">Home</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
